================================================================================
Pharmacy Care Plan Generator - 项目进度与系统设计决策总结
================================================================================
更新日期: 2026-02-14
用途: 复盘学习过程、项目开发与系统设计决策
================================================================================

一、项目来源与目标
--------------------------------------------------------------------------------
- 设计依据: design.md (Pharmacy Care Plan Auto-Generator)
- 业务: 专科药房自动生成药师 care plan，减少人工准备时间
- 用户: 内部医疗人员（药师/医疗助理），患者不直接访问
- 当前目标: 最小 MVP，先跑通全流程，逐步学习，体验缺点后再迭代

二、你一步步要求做的事（时间顺序）
--------------------------------------------------------------------------------

【第 1 步】创建最小 MVP
- 要求: 前端 + 后端 + PostgreSQL + LLM 生成 care plan 一条 API 跑通
- 不做: 限制条件、边界检查、warning/error 检查
- 不做: test cases, websocket, queue, worker, 任何 fancy 技术
- 不做: Controller-Service-Repository 分层
- Care plan 状态: pending → processing → completed/failed
- 只有 completed 时前端才显示
- 同步方式，生成时等待
- 技术: Docker, Python, Django, PostgreSQL

【第 2 步】环境变量配置
- 情况: 你已在系统环境变量配置 OPENAI_API_KEY
- 要求: 不想用 .env，问是否需要改
- 决策: 代码优先从系统环境变量读取，.env 可选

【第 3 步】Docker 报错
- 错误: version  obsolete 警告；dockerDesktopLinuxEngine 找不到
- 决策: 移除 docker-compose.yml 的 version；说明需先启动 Docker Desktop

【第 4 步】迁移报错 relation "careplan_patient" does not exist
- 原因: careplan app 的 migrations 未生成
- 决策: 创建 careplan/migrations/__init__.py；执行 makemigrations careplan + migrate

【第 5 步】Client.__init__() got an unexpected keyword argument 'proxies'
- 原因: openai 新客户端与当前环境/代理配置不兼容
- 决策: 先尝试改用 openai.ChatCompletion（老 API）

【第 6 步】openai.ChatCompletion 在 openai>=1.0 不再支持
- 决策: 一度 pin openai==0.28.1

【第 7 步】坚持使用新版 openai
- 要求: openai 版本要新，proxies 问题用 pip install -U openai httpx 解决
- 决策: 恢复 openai 1.x + httpx，使用新版 OpenAI 客户端

【第 8 步】加上下载和搜索功能
- 依据: design.md 中的 File Download、Reporting Export
- 要求: 只加下载、搜索，不加 error/warning 检查，不加其它技术
- 决策: 
  - 下载: GET /download-careplan/<id>/ 返回 .txt
  - 搜索: GET /api/search-careplans/?q=xxx 返回 JSON
  - 导出: GET /api/search-careplans/?q=xxx&export=1 返回 CSV
  - 前端增加 Download 按钮、Search 区域、Export CSV 按钮

【第 9 步】Mock 数据
- 要求: 生成 mock data 和 code，用 TablePlus 导入数据库
- 决策: 创建 scripts/load_mock_data.sql（PostgreSQL 格式），需在 TablePlus 内手动执行

【第 10 步】SQL 类型确认
- 问题: load_mock_data.sql 是 SQLite 还是 PostgreSQL？
- 决策: PostgreSQL（与你项目配置一致）

【第 11 步】运行步骤确认
- 流程: 启动 Docker → docker-compose up -d → migrate → 访问 localhost:8000

【第 12 步】查不到 mock 数据
- 原因: SQL 脚本需在 TablePlus 中手动执行，不会自动导入
- 说明: 需在 TablePlus 打开脚本并执行，且连接 pharmacy_db

【第 13 步】改为异步：加 Redis 队列
- 背景: 同步调 LLM 很慢，用户提交后需长时间等待
- 要求: 加 Redis 容器；API 存 DB + 放队列后立即返回；不写 worker 处理队列；不主动告知前端完成
- 决策:
  - 新增 redis 服务（redis:7-alpine，端口 6379）
  - generate_careplan: 创建 CarePlan(status='pending') → rpush careplan_id 到 Redis 队列 → 立即返回 {"message":"已收到","careplan_id":xxx}
  - 移除同步 LLM 调用（worker 后续再写）
  - 前端: 成功时只显示「已收到，careplan_id: xxx」，不展示内容、不展示下载
  - Redis 队列 key: careplan_queue

【第 14 步】手写 Worker
- 要求: 手写 function 处理 Redis 队列，不用 Celery；体验前端不自动更新的痛点
- 决策: 创建 management command run_careplan_worker，BLPOP 拉任务 → 调 LLM → 存 DB

【第 15 步】用 Celery 替换手写 Worker
- 要求: Celery 异步任务；失败重试最多 3 次、指数退避；更新 DB 状态；不 polling/SSE/自动更新前端
- 决策:
  - 新增 careplan/tasks.py：generate_careplan_task（@shared_task, max_retries=3, countdown=2^retries）
  - views: 用 task.delay(careplan_id) 替代 Redis rpush
  - docker-compose 新增 celery_worker 服务
  - 移除 CAREPLAN_QUEUE_KEY，Celery 用 Redis 作为 broker

【第 16 步】Docker 构建失败
- 错误: celery[redis] 导致 pip install 失败
- 决策: 改为 celery（不加 [redis] extra，redis 已在 requirements 中）

【第 17 步】用户发现：Search 即可看到新完成的 care plan
- 结论: 不需要整页刷新；点「Search Care Plans」会发起新请求查 DB，即可看到 Celery 已完成的 care plan
- 要点: 「不自动更新」指页面上无轮询/推送；任何触发新请求的操作（Search、F5、访问 /api/careplan/<id>/）都能拿到最新数据

三、系统设计决策汇总
--------------------------------------------------------------------------------

3.1 架构与分层
- 不采用 Controller-Service-Repository 分层
- 视图里直接写业务逻辑，保持简单

3.2 技术选型
- 后端: Django + Python
- 数据库: PostgreSQL
- 队列: Celery + Redis（broker + result backend）
- 容器: Docker + docker-compose（db + redis + web + celery_worker）
- LLM: OpenAI API（openai>=1.x + httpx），由 Celery worker 调用
- 无: websocket, 轮询, SSE, 主动推送前端完成

3.3 Care Plan 状态与流程
- 状态: pending → processing → completed | failed
- API 流程: 创建(pending) → task.delay(careplan_id) → 立即返回「已收到」
- Celery 流程: 取任务 → 标记 processing → 调 LLM → 成功(completed) / 失败(failed)；失败时重试最多 3 次，指数退避
- 前端: 提交后只显示「已收到，careplan_id: xxx」；用户需主动触发新请求（Search、F5 等）才能看到完成结果

3.4 数据模型
- Patient: first_name, last_name, mrn(6位唯一), dob
- Provider: name, npi(10位唯一)
- CarePlan: patient_id, provider_id, primary_diagnosis, medication_name, 
  patient_records, status, generated_content 等

3.5 API 设计
- POST /api/generate-careplan/      提交 care plan 请求（异步：存 DB + Celery 入队，立即返回）
- GET  /api/careplan/<id>/          获取单个 care plan（JSON，仅 completed 有内容）
- GET  /download-careplan/<id>/     下载 .txt 文件
- GET  /api/search-careplans/?q=xxx 搜索（JSON）
- GET  /api/search-careplans/?q=xxx&export=1  导出 CSV

3.6 校验与错误处理（当前阶段）
- 不做: 字段校验、边界检查、duplication detection、warning/error 框架
- 仅做: 必要的异常捕获，返回简单错误信息

3.7 环境变量
- OPENAI_API_KEY: 优先系统环境变量，其次 .env
- REDIS_HOST, REDIS_PORT: 用于连接 Redis（默认 redis:6379）
- Docker: 通过 docker-compose environment 传递 ${OPENAI_API_KEY}

3.8 Mock 数据
- 格式: PostgreSQL SQL
- 导入方式: 在 TablePlus 中手动执行 scripts/load_mock_data.sql
- 数据: 5 Patient, 3 Provider, 5 CarePlan（均为 completed）

四、当前项目结构
--------------------------------------------------------------------------------
pharmacy_plan_generator/
├── careplan/                 # Django app
│   ├── models.py            # Patient, Provider, CarePlan
│   ├── views.py             # index, generate_careplan, get_careplan, 
│   │                        # download_careplan, search_careplans
│   ├── tasks.py             # Celery 任务 generate_careplan_task
│   ├── llm_service.py       # OpenAI 生成 care plan（由 Celery worker 调用）
│   ├── templates/           # index.html（表单 + 搜索 + 下载）
│   ├── management/commands/ # run_careplan_worker（手写版，已被 Celery 替代）
│   └── migrations/
├── pharmacy_plan/            # 项目配置
│   ├── celery.py            # Celery app 配置
│   └── __init__.py          # 导入 celery_app
├── scripts/
│   ├── load_mock_data.sql   # Mock 数据（PostgreSQL）
│   └── README.md
├── docker-compose.yml       # db + redis + web + celery_worker
├── Dockerfile
├── requirements.txt         # 含 celery, redis
├── design.md                # 原始设计文档
└── progress_summary.txt     # 本文件

五、design.md 中尚未实现的部分（后续可迭代）
--------------------------------------------------------------------------------
- 输入校验（MRN 6 位、NPI 10 位、ICD-10 等）
- Duplication detection（patient/order/provider）
- Error vs Warning 行为区分
- PDF 解析（Patient Records）
- duplication_warning 在报表中的实际逻辑

六、Celery 改造后尚未实现的部分
--------------------------------------------------------------------------------
- 前端获知完成: 轮询 /api/careplan/<id>/ 或 WebSocket/SSE 推送（你后续学习）

七、今日问答与发现
--------------------------------------------------------------------------------
- 不需要整页刷新也能看到新完成的 care plan：点「Search Care Plans」会发起新请求查 DB，即可看到结果
- 「不自动更新」的含义：页面上无轮询、无推送；任何触发新 HTTP 请求的操作都能拿到最新数据

================================================================================
