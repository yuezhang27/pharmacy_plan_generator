================================================================================
Pharmacy Care Plan Generator - 项目进度与系统设计决策总结
================================================================================
更新日期: 2026-02-13
用途: 复盘学习过程、项目开发与系统设计决策
================================================================================

一、项目来源与目标
--------------------------------------------------------------------------------
- 设计依据: design.md (Pharmacy Care Plan Auto-Generator)
- 业务: 专科药房自动生成药师 care plan，减少人工准备时间
- 用户: 内部医疗人员（药师/医疗助理），患者不直接访问
- 当前目标: 最小 MVP，先跑通全流程，逐步学习，体验缺点后再迭代

二、你一步步要求做的事（时间顺序）
--------------------------------------------------------------------------------

【第 1 步】创建最小 MVP
- 要求: 前端 + 后端 + PostgreSQL + LLM 生成 care plan 一条 API 跑通
- 不做: 限制条件、边界检查、warning/error 检查
- 不做: test cases, websocket, queue, worker, 任何 fancy 技术
- 不做: Controller-Service-Repository 分层
- Care plan 状态: pending → processing → completed/failed
- 只有 completed 时前端才显示
- 同步方式，生成时等待
- 技术: Docker, Python, Django, PostgreSQL

【第 2 步】环境变量配置
- 情况: 你已在系统环境变量配置 OPENAI_API_KEY
- 要求: 不想用 .env，问是否需要改
- 决策: 代码优先从系统环境变量读取，.env 可选

【第 3 步】Docker 报错
- 错误: version  obsolete 警告；dockerDesktopLinuxEngine 找不到
- 决策: 移除 docker-compose.yml 的 version；说明需先启动 Docker Desktop

【第 4 步】迁移报错 relation "careplan_patient" does not exist
- 原因: careplan app 的 migrations 未生成
- 决策: 创建 careplan/migrations/__init__.py；执行 makemigrations careplan + migrate

【第 5 步】Client.__init__() got an unexpected keyword argument 'proxies'
- 原因: openai 新客户端与当前环境/代理配置不兼容
- 决策: 先尝试改用 openai.ChatCompletion（老 API）

【第 6 步】openai.ChatCompletion 在 openai>=1.0 不再支持
- 决策: 一度 pin openai==0.28.1

【第 7 步】坚持使用新版 openai
- 要求: openai 版本要新，proxies 问题用 pip install -U openai httpx 解决
- 决策: 恢复 openai 1.x + httpx，使用新版 OpenAI 客户端

【第 8 步】加上下载和搜索功能
- 依据: design.md 中的 File Download、Reporting Export
- 要求: 只加下载、搜索，不加 error/warning 检查，不加其它技术
- 决策: 
  - 下载: GET /download-careplan/<id>/ 返回 .txt
  - 搜索: GET /api/search-careplans/?q=xxx 返回 JSON
  - 导出: GET /api/search-careplans/?q=xxx&export=1 返回 CSV
  - 前端增加 Download 按钮、Search 区域、Export CSV 按钮

【第 9 步】Mock 数据
- 要求: 生成 mock data 和 code，用 TablePlus 导入数据库
- 决策: 创建 scripts/load_mock_data.sql（PostgreSQL 格式），需在 TablePlus 内手动执行

【第 10 步】SQL 类型确认
- 问题: load_mock_data.sql 是 SQLite 还是 PostgreSQL？
- 决策: PostgreSQL（与你项目配置一致）

【第 11 步】运行步骤确认
- 流程: 启动 Docker → docker-compose up -d → migrate → 访问 localhost:8000

【第 12 步】查不到 mock 数据
- 原因: SQL 脚本需在 TablePlus 中手动执行，不会自动导入
- 说明: 需在 TablePlus 打开脚本并执行，且连接 pharmacy_db

【第 13 步】改为异步：加 Redis 队列
- 背景: 同步调 LLM 很慢，用户提交后需长时间等待
- 要求: 加 Redis 容器；API 存 DB + 放队列后立即返回；不写 worker 处理队列；不主动告知前端完成
- 决策:
  - 新增 redis 服务（redis:7-alpine，端口 6379）
  - generate_careplan: 创建 CarePlan(status='pending') → rpush careplan_id 到 Redis 队列 → 立即返回 {"message":"已收到","careplan_id":xxx}
  - 移除同步 LLM 调用（worker 后续再写）
  - 前端: 成功时只显示「已收到，careplan_id: xxx」，不展示内容、不展示下载
  - Redis 队列 key: careplan_queue

【第 14 步】手写 Worker
- 要求: 手写 function 处理 Redis 队列，不用 Celery；体验前端不自动更新的痛点
- 决策: 创建 management command run_careplan_worker，BLPOP 拉任务 → 调 LLM → 存 DB

【第 15 步】用 Celery 替换手写 Worker
- 要求: Celery 异步任务；失败重试最多 3 次、指数退避；更新 DB 状态；不 polling/SSE/自动更新前端
- 决策:
  - 新增 careplan/tasks.py：generate_careplan_task（@shared_task, max_retries=3, countdown=2^retries）
  - views: 用 task.delay(careplan_id) 替代 Redis rpush
  - docker-compose 新增 celery_worker 服务
  - 移除 CAREPLAN_QUEUE_KEY，Celery 用 Redis 作为 broker

【第 16 步】Docker 构建失败
- 错误: celery[redis] 导致 pip install 失败
- 决策: 改为 celery（不加 [redis] extra，redis 已在 requirements 中）

【第 17 步】用户发现：Search 即可看到新完成的 care plan
- 结论: 不需要整页刷新；点「Search Care Plans」会发起新请求查 DB，即可看到 Celery 已完成的 care plan
- 要点: 「不自动更新」指页面上无轮询/推送；任何触发新请求的操作（Search、F5、访问 /api/careplan/<id>/）都能拿到最新数据

【第 18 步】实现 Polling
- 要求: Worker 完成后前端能获知；用 Polling 实现
- 决策:
  - 后端: GET /api/careplan/<id>/status/ 返回 status 和 content（若 completed）或 error（若 failed）
  - 前端: 提交后拿到 careplan_id，每 3 秒轮询；completed 停止并显示结果；failed 停止并显示错误

【第 19 步】Mock LLM
- 要求: 开发/测试时不真调 LLM，用 mock 代替；能跑通 Worker 全流程
- 决策:
  - llm_service: 新增 generate_careplan_mock（返回固定文本）、generate_careplan（统一入口，按配置切换）
  - 配置: USE_MOCK_LLM=1 用 mock，=0 用真实 LLM；默认 1
  - 切换: 环境变量 USE_MOCK_LLM，docker-compose 传 ${USE_MOCK_LLM:-1}

【第 20 步】views.py 拆分
- 要求: views 只负责请求/响应；serializers 负责数据校验和格式转换；services 负责业务逻辑
- 决策:
  - views.py: 只接收请求、调用 service/serializer、返回 HttpResponse/JsonResponse
  - serializers.py: parse_generate_careplan_request（JSON → dict）
  - services.py: create_careplan, get_careplan_detail, get_careplan_status, get_careplan_download, search_careplans
  - 不改变任何功能，仅搬迁代码；详见 REFACTOR_MIGRATION_TABLE.md

【第 21 步】验证方式
- 问题: 拆分后如何验证 API 行为一致？
- 结论: docker-compose up -d 后 E2E 跑一遍主流程即可，不必逐个 router 单独测

【第 22 步】统一错误处理系统
- 要求: BaseAppException 基类；ValidationError/BlockError/WarningException 子类；统一 exception_handler；兼容 DRF ValidationError
- 决策:
  - BaseAppException: type, code, message, detail, http_status
  - ValidationError(400): serializer 校验失败
  - BlockError(409): 业务阻止（NPI 姓名不一致、同日重复订单等）
  - WarningException(200): 业务警告（MRN/姓名+DOB 重复，用户 confirm 可继续）
  - AppExceptionMiddleware 捕获异常，交由 app_exception_handler 转 JSON
  - 前端统一用 success/type/code 判断，无需多处 if-else

【第 23 步】单元测试、集成测试与 Docker 测试
- 要求: Patient 重复检测 90% 覆盖率；集成测试；错误输入对应错误响应；用 Docker 跑测试
- 决策:
  - 新增 pytest, pytest-django, pytest-cov
  - careplan/tests/: test_duplication_patient, test_duplication_provider_order, test_errors, test_integration
  - docker-compose 新增 test 服务：pytest careplan/tests/ --cov
  - 测试策略: 见下方 3.10

【第 24 步】README 补充 Patient 重复检测原则
- 要求: 明确 MRN 已存在 / 姓名+DOB 已存在时，用户选择「继续」后的系统行为
- 决策（写入 README）:
  - MRN 已存在，但输入的姓名或 DOB 与现有记录不一致：即使用户选择「继续」，系统仍以**原有 MRN 关联的既有人口学信息**为准（MRN 是患者唯一标识符）
  - 姓名+DOB 与现有某人一致，但 MRN 不同：用户选择「继续」时，系统以**新 MRN 关联的新人口学信息**为准，创建新记录（可能是同名同生日不同人）

【第 25 步】数据格式校验
- 要求: NPI 10 位、MRN 6 位、ICD-10 格式、必填字段
- 决策:
  - serializers.validate_generate_careplan_data：校验必填、NPI、MRN、DOB(YYYY-MM-DD)、ICD-10
  - parse_generate_careplan_request 在 json.loads 成功后调用 validate_generate_careplan_data
  - 失败时 ValidationError，detail.errors 包含所有错误列表
  - 新增 test_serializers_validation.py

【第 26 步】多数据源 Intake Adapter
- 要求: 不同医院/诊所数据格式不同（JSON/XML、字段命名各异），统一转 InternalOrder
- 决策:
  - InternalOrder dataclass（patient, provider, careplan, source, raw_data）
  - BaseIntakeAdapter：parse → transform → validate
  - WebFormAdapter（现有表单 JSON）、PharmaCorpAdapter（XML）、MedCenterJsonAdapter（clinic_b JSON）
  - get_adapter(source) 工厂；views 使用 adapter.process()，业务只认识 InternalOrder
  - 新增 /api/intake/pharmacorp/、/api/intake/medcenter/

【第 27 步】LLM Service 抽象层
- 要求: 支持 OpenAI/Claude 切换，业务代码不依赖具体 LLM；前端可选模型
- 决策:
  - BaseLLMService 抽象基类：generate(system_message, user_message) -> str
  - OpenAIService、ClaudeService、MockLLMService 实现（Adapter 模式）
  - get_llm_service(provider) 工厂；USE_MOCK_LLM=1 强制 mock
  - CarePlan.llm_provider 字段；前端 LLM Model 下拉框；任务执行时按 careplan.llm_provider 选择
  - 移除旧 careplan/model/；新增 careplan/llm_providers/

【第 28 步】前端与 E2E 改进
- E2E 报错 "Unexpected token '<'"：服务器返回 HTML（500）而非 JSON
- 决策: 前端先 response.text() 再 JSON.parse，解析失败时显示友好提示（如「可能需执行 migrate」）
- 格式校验已由 Intake Adapter 的 validate 承担，与 serializers 一致

【第 29 步】Prometheus + Grafana 监控
- 要求: 用 Prometheus + Grafana 做监控，指标见 DASHBOARD_METRICS.md
- 决策:
  - careplan/metrics.py 定义 Prometheus 指标；views_metrics 暴露 /metrics
  - MetricsMiddleware 记录 API 耗时、HTTP 4xx/5xx
  - Celery prefork 下 careplan_completed_total 无法统计（子进程与主进程隔离）
  - 改用 StatsD：Worker 通过 UDP 发指标 → statsd_exporter → Prometheus
  - docker-compose 新增 prometheus、grafana、statsd_exporter

【第 30 步】Terraform AWS 一键部署
- 要求: 用 Terraform 一键部署到 AWS；SQS + DLQ（失败 3 次进 DLQ）；RDS PostgreSQL db.t3.micro；3 个 Lambda（create_order、generate_careplan、get_order）；API Gateway
- 决策:
  - terraform/ 目录：VPC、RDS、SQS、Lambda、API Gateway
  - POST /orders → create_order Lambda（写 RDS + 发 SQS）
  - SQS 触发 generate_careplan Lambda（Mock LLM 更新 RDS）
  - GET /orders/{id} → get_order Lambda（查 RDS）
  - Lambda 用 pg8000（纯 Python，兼容 Lambda Linux）；psycopg2-binary 在 Windows 编译无法在 Lambda 运行
  - RDS 要求 SSL：连接时加 ssl_context
  - Lambda 不配置 VPC：RDS 已 publicly_accessible，Lambda 默认有互联网可连 RDS 和 SQS
  - 部署前需 python scripts/build_lambdas.py 构建 Lambda 包
  - terraform.tfvars 含 db_password，已加入 .gitignore

三、系统设计决策汇总
--------------------------------------------------------------------------------

3.1 架构与分层
- views-intake-services 分层：
  - views: 只负责接收请求、调用 get_adapter().process()、返回响应
  - intake: 多数据源 Adapter（parse/transform/validate）→ InternalOrder → to_create_careplan_dict()
  - services: 所有业务逻辑（DB、Celery、LLM）；只认识 create_careplan(data) 的 dict 格式
  - serializers: 格式校验逻辑已并入 intake adapter.validate，保留供测试

3.2 技术选型
- 后端: Django + Python
- 数据库: PostgreSQL
- 队列: Celery + Redis（broker + result backend）
- 容器: Docker + docker-compose（db + redis + web + celery_worker + test）
- LLM: 抽象层 careplan/llm_providers/；支持 OpenAI、Claude、Mock；USE_MOCK_LLM 切换
- 前端获知完成: Polling（每 3 秒调 /api/careplan/<id>/status/）

3.3 Care Plan 状态与流程
- 状态: pending → processing → completed | failed
- API 流程: 创建(pending) → task.delay(careplan_id) → 立即返回「已收到」
- Celery 流程: 取任务 → 标记 processing → 调 LLM（或 mock）→ 成功(completed) / 失败(failed)；失败时重试最多 3 次，指数退避
- 前端: 提交后轮询 status API；completed 时显示结果和下载；failed 时显示错误

3.4 数据模型
- Patient: first_name, last_name, mrn(6位唯一), dob
- Provider: name, npi(10位唯一)
- CarePlan: patient_id, provider_id, primary_diagnosis, medication_name, 
  patient_records, status, generated_content, llm_provider（可选，openai/claude）等

3.5 API 设计
- POST /api/generate-careplan/      提交 care plan（WebForm JSON，X-Intake-Source 默认 webform）
- POST /api/intake/pharmacorp/      PharmaCorp XML 接入
- POST /api/intake/medcenter/       MedCenter JSON 接入
- GET  /api/careplan/<id>/          获取单个 care plan（JSON，仅 completed 有内容）
- GET  /api/careplan/<id>/status/   轮询用：返回 status、content（completed 时）、error（failed 时）
- GET  /download-careplan/<id>/     下载 .txt 文件
- GET  /api/search-careplans/?q=xxx 搜索（JSON）
- GET  /api/search-careplans/?q=xxx&export=1  导出 CSV

3.6 校验与错误处理（已实现）
- BaseAppException 统一格式: success, type, code, message, detail
- ValidationError(400): 输入格式错误（JSON 解析失败、格式校验失败）
- 格式校验（serializers）: NPI 10 位数字、MRN 6 位数字、DOB YYYY-MM-DD、ICD-10（如 A00, E11.9）、必填字段非空
- BlockError(409): 业务阻止（NPI 姓名不一致、同日重复订单、CarePlan 不存在等）
- WarningException(200): 业务警告（MRN/姓名+DOB 重复，confirm 可继续）
- Duplication detection: Provider(NPI+名字)、Patient(MRN/姓名+DOB)、Order(同日/异日)

3.7 环境变量
- OPENAI_API_KEY, ANTHROPIC_API_KEY: LLM API 密钥
- USE_MOCK_LLM: 1=mock（不调真实 API），0=真实 LLM；默认 1
- LLM_PROVIDER: openai | claude；USE_MOCK_LLM=0 时生效
- REDIS_HOST, REDIS_PORT: 用于连接 Redis（默认 redis:6379）
- Docker: 通过 docker-compose environment 传递

3.8 LLM 抽象层
- BaseLLMService.generate(system_message, user_message) -> str；业务只依赖此接口
- OpenAIService、ClaudeService、MockLLMService；get_llm_service(provider) 工厂
- 前端 LLM Model 下拉框可选 openai/claude；存入 CarePlan.llm_provider，任务执行时使用

3.9 数据库 Mock 数据
- 格式: PostgreSQL SQL
- 导入方式: 在 TablePlus 中手动执行 scripts/load_mock_data.sql
- 数据: 5 Patient, 3 Provider, 5 CarePlan（均为 completed）

3.10 测试策略
- 框架: pytest + pytest-django + pytest-cov
- 测试用 SQLite 而不使用 PostgreSQL: 本地运行 pytest 时设置 USE_SQLITE_FOR_TESTS=1，settings 会切换为 sqlite3 :memory:，无需启动 Docker/PostgreSQL
- Docker 跑测试: docker-compose run --rm test，使用 PostgreSQL（与生产一致）
- 测试分类:
  - Unit: test_duplication_patient、test_duplication_provider_order、test_serializers_validation、test_llm_providers、test_intake_adapters
  - Integration: test_integration（完整 API 流程）
  - Error: test_errors（错误输入 → 对应错误响应）
- Celery 任务: 测试中 mock generate_careplan_task.delay
- Claude 测试: anthropic 未安装时 pytest.importorskip 跳过

3.11 Patient 重复检测原则（业务规则）
- MRN 已存在 + 姓名/DOB 不一致 + 用户继续 → 以**原有 MRN 的既有人口学信息**为准（MRN 为唯一标识）
- 姓名+DOB 已存在 + MRN 不同 + 用户继续 → 以**新 MRN 的新人口学信息**为准，创建新记录（同名同生日不同人）

3.12 Middleware 与 Exception Handler 的关系
- Django 机制：view 抛异常时，只有 middleware 的 process_exception 会被调用；没有「全局异常处理器」配置
- 若不在每个 view 显式 try/except 调用 handler，就必须用 middleware 统一拦截
- Middleware 放 settings 最后 → process_exception 时**最先**被调用（反向顺序）
- Handler 是业务逻辑函数，Middleware 是 Django 钩子；分离便于测试和复用

四、当前项目结构
--------------------------------------------------------------------------------
pharmacy_plan_generator/
├── careplan/                 # Django app
│   ├── models.py            # Patient, Provider, CarePlan（含 llm_provider）
│   ├── views.py             # 调用 intake get_adapter、services
│   ├── serializers.py       # 格式校验（已并入 intake，保留供测试）
│   ├── services.py          # create_careplan, get_careplan_detail 等
│   ├── duplication_detection.py  # check_provider, check_patient, check_order
│   ├── intake/              # 多数据源 Adapter
│   │   ├── types.py         # InternalOrder, PatientInfo, ProviderInfo, CarePlanInfo
│   │   ├── adapters.py      # WebFormAdapter, PharmaCorpAdapter, MedCenterJsonAdapter
│   │   ├── factory.py       # get_adapter
│   │   └── README.md
│   ├── llm_providers/       # LLM 抽象层
│   │   ├── base.py          # BaseLLMService
│   │   ├── openai_service.py
│   │   ├── claude_service.py
│   │   ├── mock_service.py
│   │   ├── factory.py       # get_llm_service
│   │   └── README.md
│   ├── llm_service.py       # generate_careplan 统一入口
│   ├── tasks.py             # Celery 任务 generate_careplan_task
│   ├── templates/           # index.html（表单 + LLM 下拉 + 搜索 + 下载）
│   ├── tests/
│   │   ├── test_duplication_patient.py
│   │   ├── test_duplication_provider_order.py
│   │   ├── test_errors.py
│   │   ├── test_integration.py
│   │   ├── test_serializers_validation.py
│   │   ├── test_intake_adapters.py
│   │   └── test_llm_providers.py
│   ├── management/commands/
│   └── migrations/
├── pharmacy_plan/            # 项目配置
│   ├── exceptions.py        # BaseAppException, ValidationError, BlockError, WarningException
│   ├── exception_handler.py # app_exception_handler
│   ├── middleware.py        # AppExceptionMiddleware
│   ├── celery.py            # Celery app 配置
│   └── __init__.py          # 导入 celery_app
├── scripts/
│   ├── load_mock_data.sql   # Mock 数据（PostgreSQL）
│   └── README.md
├── conftest.py              # pytest fixtures
├── pytest.ini               # pytest 配置
├── .coveragerc              # coverage 配置
├── docker-compose.yml       # db + redis + web + celery_worker + test
├── Dockerfile
├── requirements.txt         # 含 celery, redis, openai, anthropic, pytest, pytest-django, pytest-cov
├── design.md                # 原始设计文档
├── REFACTOR_MIGRATION_TABLE.md  # views 拆分迁移表
├── terraform/               # AWS 部署（RDS + SQS + Lambda + API Gateway）
│   ├── main.tf
│   ├── variables.tf
│   ├── outputs.tf
│   ├── lambdas/             # create_order, generate_careplan, get_order
│   └── scripts/build_lambdas.py
└── progress_summary.txt     # 本文件

五、design.md 中尚未实现的部分（后续可迭代）
--------------------------------------------------------------------------------
- 输入校验（MRN 6 位、NPI 10 位、ICD-10 等）— 已实现（serializers.validate_generate_careplan_data）
- Duplication detection（patient/order/provider）— 已实现
- Error vs Warning 行为区分 — 已实现（BlockError/WarningException）
- PDF 解析（Patient Records）
- duplication_warning 在报表中的实际逻辑

六、尚未实现的部分
--------------------------------------------------------------------------------
- WebSocket/SSE 推送完成状态（当前用 Polling）

七、今日问答与发现
--------------------------------------------------------------------------------
- **LLM 抽象层是否用 Adapter 模式**：已使用；BaseLLMService.generate 为目标接口，OpenAIService/ClaudeService 将各自 API 适配为统一接口
- **E2E "Unexpected token '<'"**：服务器返回 HTML（500）而非 JSON；原因多为 migrate 未执行（llm_provider 字段）；前端改为先 text() 再 parse，失败时提示「可能需执行 migrate」
- **AppExceptionMiddleware 疑惑**：Django 没有 view 异常的全局钩子，只有 middleware 的 process_exception 能拦截
- **E2E 发现 format validation 未实现**：已由 Intake Adapter 的 validate 承担
- 测试策略：本地开发用 USE_SQLITE_FOR_TESTS=1 跑 pytest，无需 PostgreSQL；Docker 跑测试用 PostgreSQL 与生产一致
- 不需要整页刷新也能看到新完成的 care plan：点「Search Care Plans」会发起新请求查 DB，即可看到结果
- 「不自动更新」的含义：页面上无轮询、无推送；任何触发新 HTTP 请求的操作都能拿到最新数据
- Polling 实现后：前端提交后每 3 秒轮询 status API，completed/failed 时自动停止并展示
- Mock LLM：USE_MOCK_LLM=1 开发，=0 生产；可跑通 Redis → Worker → DB 全流程而不消耗 API
- 拆分后验证：E2E 跑一遍主流程即可，不必逐个 router 单独测
- Terraform 部署：destroy 后未来可重新 init/plan/apply；terraform.tfvars 含敏感信息不提交，需重新创建

================================================================================
