================================================================================
Pharmacy Care Plan Generator - 项目进度与系统设计决策总结
================================================================================
更新日期: 2026-02-12
用途: 复盘学习过程、项目开发与系统设计决策
================================================================================

一、项目来源与目标
--------------------------------------------------------------------------------
- 设计依据: design.md (Pharmacy Care Plan Auto-Generator)
- 业务: 专科药房自动生成药师 care plan，减少人工准备时间
- 用户: 内部医疗人员（药师/医疗助理），患者不直接访问
- 当前目标: 最小 MVP，先跑通全流程，逐步学习，体验缺点后再迭代

二、你一步步要求做的事（时间顺序）
--------------------------------------------------------------------------------

【第 1 步】创建最小 MVP
- 要求: 前端 + 后端 + PostgreSQL + LLM 生成 care plan 一条 API 跑通
- 不做: 限制条件、边界检查、warning/error 检查
- 不做: test cases, websocket, queue, worker, 任何 fancy 技术
- 不做: Controller-Service-Repository 分层
- Care plan 状态: pending → processing → completed/failed
- 只有 completed 时前端才显示
- 同步方式，生成时等待
- 技术: Docker, Python, Django, PostgreSQL

【第 2 步】环境变量配置
- 情况: 你已在系统环境变量配置 OPENAI_API_KEY
- 要求: 不想用 .env，问是否需要改
- 决策: 代码优先从系统环境变量读取，.env 可选

【第 3 步】Docker 报错
- 错误: version  obsolete 警告；dockerDesktopLinuxEngine 找不到
- 决策: 移除 docker-compose.yml 的 version；说明需先启动 Docker Desktop

【第 4 步】迁移报错 relation "careplan_patient" does not exist
- 原因: careplan app 的 migrations 未生成
- 决策: 创建 careplan/migrations/__init__.py；执行 makemigrations careplan + migrate

【第 5 步】Client.__init__() got an unexpected keyword argument 'proxies'
- 原因: openai 新客户端与当前环境/代理配置不兼容
- 决策: 先尝试改用 openai.ChatCompletion（老 API）

【第 6 步】openai.ChatCompletion 在 openai>=1.0 不再支持
- 决策: 一度 pin openai==0.28.1

【第 7 步】坚持使用新版 openai
- 要求: openai 版本要新，proxies 问题用 pip install -U openai httpx 解决
- 决策: 恢复 openai 1.x + httpx，使用新版 OpenAI 客户端

【第 8 步】加上下载和搜索功能
- 依据: design.md 中的 File Download、Reporting Export
- 要求: 只加下载、搜索，不加 error/warning 检查，不加其它技术
- 决策: 
  - 下载: GET /download-careplan/<id>/ 返回 .txt
  - 搜索: GET /api/search-careplans/?q=xxx 返回 JSON
  - 导出: GET /api/search-careplans/?q=xxx&export=1 返回 CSV
  - 前端增加 Download 按钮、Search 区域、Export CSV 按钮

【第 9 步】Mock 数据
- 要求: 生成 mock data 和 code，用 TablePlus 导入数据库
- 决策: 创建 scripts/load_mock_data.sql（PostgreSQL 格式），需在 TablePlus 内手动执行

【第 10 步】SQL 类型确认
- 问题: load_mock_data.sql 是 SQLite 还是 PostgreSQL？
- 决策: PostgreSQL（与你项目配置一致）

【第 11 步】运行步骤确认
- 流程: 启动 Docker → docker-compose up -d → migrate → 访问 localhost:8000

【第 12 步】查不到 mock 数据
- 原因: SQL 脚本需在 TablePlus 中手动执行，不会自动导入
- 说明: 需在 TablePlus 打开脚本并执行，且连接 pharmacy_db

【第 13 步】改为异步：加 Redis 队列
- 背景: 同步调 LLM 很慢，用户提交后需长时间等待
- 要求: 加 Redis 容器；API 存 DB + 放队列后立即返回；不写 worker 处理队列；不主动告知前端完成
- 决策:
  - 新增 redis 服务（redis:7-alpine，端口 6379）
  - generate_careplan: 创建 CarePlan(status='pending') → rpush careplan_id 到 Redis 队列 → 立即返回 {"message":"已收到","careplan_id":xxx}
  - 移除同步 LLM 调用（worker 后续再写）
  - 前端: 成功时只显示「已收到，careplan_id: xxx」，不展示内容、不展示下载
  - Redis 队列 key: careplan_queue

【第 14 步】手写 Worker
- 要求: 手写 function 处理 Redis 队列，不用 Celery；体验前端不自动更新的痛点
- 决策: 创建 management command run_careplan_worker，BLPOP 拉任务 → 调 LLM → 存 DB

【第 15 步】用 Celery 替换手写 Worker
- 要求: Celery 异步任务；失败重试最多 3 次、指数退避；更新 DB 状态；不 polling/SSE/自动更新前端
- 决策:
  - 新增 careplan/tasks.py：generate_careplan_task（@shared_task, max_retries=3, countdown=2^retries）
  - views: 用 task.delay(careplan_id) 替代 Redis rpush
  - docker-compose 新增 celery_worker 服务
  - 移除 CAREPLAN_QUEUE_KEY，Celery 用 Redis 作为 broker

【第 16 步】Docker 构建失败
- 错误: celery[redis] 导致 pip install 失败
- 决策: 改为 celery（不加 [redis] extra，redis 已在 requirements 中）

【第 17 步】用户发现：Search 即可看到新完成的 care plan
- 结论: 不需要整页刷新；点「Search Care Plans」会发起新请求查 DB，即可看到 Celery 已完成的 care plan
- 要点: 「不自动更新」指页面上无轮询/推送；任何触发新请求的操作（Search、F5、访问 /api/careplan/<id>/）都能拿到最新数据

【第 18 步】实现 Polling
- 要求: Worker 完成后前端能获知；用 Polling 实现
- 决策:
  - 后端: GET /api/careplan/<id>/status/ 返回 status 和 content（若 completed）或 error（若 failed）
  - 前端: 提交后拿到 careplan_id，每 3 秒轮询；completed 停止并显示结果；failed 停止并显示错误

【第 19 步】Mock LLM
- 要求: 开发/测试时不真调 LLM，用 mock 代替；能跑通 Worker 全流程
- 决策:
  - llm_service: 新增 generate_careplan_mock（返回固定文本）、generate_careplan（统一入口，按配置切换）
  - 配置: USE_MOCK_LLM=1 用 mock，=0 用真实 LLM；默认 1
  - 切换: 环境变量 USE_MOCK_LLM，docker-compose 传 ${USE_MOCK_LLM:-1}

【第 20 步】views.py 拆分
- 要求: views 只负责请求/响应；serializers 负责数据校验和格式转换；services 负责业务逻辑
- 决策:
  - views.py: 只接收请求、调用 service/serializer、返回 HttpResponse/JsonResponse
  - serializers.py: parse_generate_careplan_request（JSON → dict）
  - services.py: create_careplan, get_careplan_detail, get_careplan_status, get_careplan_download, search_careplans
  - 不改变任何功能，仅搬迁代码；详见 REFACTOR_MIGRATION_TABLE.md

【第 21 步】验证方式
- 问题: 拆分后如何验证 API 行为一致？
- 结论: docker-compose up -d 后 E2E 跑一遍主流程即可，不必逐个 router 单独测

【第 22 步】统一错误处理系统
- 要求: BaseAppException 基类；ValidationError/BlockError/WarningException 子类；统一 exception_handler；兼容 DRF ValidationError
- 决策:
  - BaseAppException: type, code, message, detail, http_status
  - ValidationError(400): serializer 校验失败
  - BlockError(409): 业务阻止（NPI 姓名不一致、同日重复订单等）
  - WarningException(200): 业务警告（MRN/姓名+DOB 重复，用户 confirm 可继续）
  - AppExceptionMiddleware 捕获异常，交由 app_exception_handler 转 JSON
  - 前端统一用 success/type/code 判断，无需多处 if-else

【第 23 步】单元测试、集成测试与 Docker 测试
- 要求: Patient 重复检测 90% 覆盖率；集成测试；错误输入对应错误响应；用 Docker 跑测试
- 决策:
  - 新增 pytest, pytest-django, pytest-cov
  - careplan/tests/: test_duplication_patient, test_duplication_provider_order, test_errors, test_integration
  - docker-compose 新增 test 服务：pytest careplan/tests/ --cov
  - 测试策略: 见下方 3.10

三、系统设计决策汇总
--------------------------------------------------------------------------------

3.1 架构与分层
- views-serializers-services 分层：
  - views: 只负责接收请求、返回响应
  - serializers: 数据校验和格式转换（前端 ↔ 后端）
  - services: 所有业务逻辑（DB、Celery、LLM）

3.2 技术选型
- 后端: Django + Python
- 数据库: PostgreSQL
- 队列: Celery + Redis（broker + result backend）
- 容器: Docker + docker-compose（db + redis + web + celery_worker）
- LLM: OpenAI API（openai>=1.x + httpx），由 Celery worker 调用；支持 USE_MOCK_LLM 切换 mock
- 前端获知完成: Polling（每 3 秒调 /api/careplan/<id>/status/）

3.3 Care Plan 状态与流程
- 状态: pending → processing → completed | failed
- API 流程: 创建(pending) → task.delay(careplan_id) → 立即返回「已收到」
- Celery 流程: 取任务 → 标记 processing → 调 LLM（或 mock）→ 成功(completed) / 失败(failed)；失败时重试最多 3 次，指数退避
- 前端: 提交后轮询 status API；completed 时显示结果和下载；failed 时显示错误

3.4 数据模型
- Patient: first_name, last_name, mrn(6位唯一), dob
- Provider: name, npi(10位唯一)
- CarePlan: patient_id, provider_id, primary_diagnosis, medication_name, 
  patient_records, status, generated_content 等

3.5 API 设计
- POST /api/generate-careplan/      提交 care plan 请求（异步：存 DB + Celery 入队，立即返回）
- GET  /api/careplan/<id>/          获取单个 care plan（JSON，仅 completed 有内容）
- GET  /api/careplan/<id>/status/   轮询用：返回 status、content（completed 时）、error（failed 时）
- GET  /download-careplan/<id>/     下载 .txt 文件
- GET  /api/search-careplans/?q=xxx 搜索（JSON）
- GET  /api/search-careplans/?q=xxx&export=1  导出 CSV

3.6 校验与错误处理（已实现）
- BaseAppException 统一格式: success, type, code, message, detail
- ValidationError(400): 输入格式错误（如 JSON 解析失败）
- BlockError(409): 业务阻止（NPI 姓名不一致、同日重复订单、CarePlan 不存在等）
- WarningException(200): 业务警告（MRN/姓名+DOB 重复，confirm 可继续）
- Duplication detection: Provider(NPI+名字)、Patient(MRN/姓名+DOB)、Order(同日/异日)

3.7 环境变量
- OPENAI_API_KEY: 优先系统环境变量，其次 .env
- USE_MOCK_LLM: 1=mock LLM（不调 OpenAI），0=真实 LLM；默认 1
- REDIS_HOST, REDIS_PORT: 用于连接 Redis（默认 redis:6379）
- Docker: 通过 docker-compose environment 传递 ${OPENAI_API_KEY}、${USE_MOCK_LLM:-1}

3.8 LLM 模式切换
- Mock 模式（开发/测试）: USE_MOCK_LLM=1 或不设置；generate_careplan_mock 返回固定文本
- Prod 模式: USE_MOCK_LLM=0；调用 OpenAI API

3.9 数据库 Mock 数据
- 格式: PostgreSQL SQL
- 导入方式: 在 TablePlus 中手动执行 scripts/load_mock_data.sql
- 数据: 5 Patient, 3 Provider, 5 CarePlan（均为 completed）

3.10 测试策略
- 框架: pytest + pytest-django + pytest-cov
- 测试用 SQLite 而不使用 PostgreSQL: 本地运行 pytest 时设置 USE_SQLITE_FOR_TESTS=1，settings 会切换为 sqlite3 :memory:，无需启动 Docker/PostgreSQL
- Docker 跑测试: docker-compose run --rm test，使用 PostgreSQL（与生产一致）
- 测试分类:
  - Unit: test_duplication_patient（Patient 重复检测，目标 90% 覆盖率）、test_duplication_provider_order（Provider/Order）
  - Integration: test_integration（完整 API 流程：create、status、search）
  - Error: test_errors（错误输入 → 对应错误响应：invalid JSON、METHOD_NOT_ALLOWED、PROVIDER_NPI_NAME_MISMATCH、PATIENT_MRN_MISMATCH、ORDER_SAME_DAY_DUPLICATE、NOT_FOUND 等）
- Celery 任务: 测试中 mock generate_careplan_task.delay，不实际执行 Celery

四、当前项目结构
--------------------------------------------------------------------------------
pharmacy_plan_generator/
├── careplan/                 # Django app
│   ├── models.py            # Patient, Provider, CarePlan
│   ├── views.py             # 只负责请求/响应
│   ├── serializers.py       # 数据校验和格式转换（parse_generate_careplan_request）
│   ├── services.py          # 业务逻辑（create_careplan, get_careplan_detail 等）
│   ├── duplication_detection.py  # check_provider, check_patient, check_order
│   ├── tasks.py             # Celery 任务 generate_careplan_task
│   ├── llm_service.py       # generate_careplan（统一入口）、generate_careplan_mock、
│   │                        # generate_careplan_with_llm（真实 OpenAI）
│   ├── templates/           # index.html（表单 + 搜索 + 下载）
│   ├── tests/               # pytest 测试
│   │   ├── test_duplication_patient.py    # Patient 重复检测（90% 覆盖率目标）
│   │   ├── test_duplication_provider_order.py
│   │   ├── test_errors.py   # 错误输入 → 对应错误响应
│   │   └── test_integration.py
│   ├── management/commands/ # run_careplan_worker（手写版，已被 Celery 替代）
│   └── migrations/
├── pharmacy_plan/            # 项目配置
│   ├── exceptions.py        # BaseAppException, ValidationError, BlockError, WarningException
│   ├── exception_handler.py # app_exception_handler
│   ├── middleware.py        # AppExceptionMiddleware
│   ├── celery.py            # Celery app 配置
│   └── __init__.py          # 导入 celery_app
├── scripts/
│   ├── load_mock_data.sql   # Mock 数据（PostgreSQL）
│   └── README.md
├── conftest.py              # pytest fixtures
├── pytest.ini               # pytest 配置
├── .coveragerc              # coverage 配置
├── docker-compose.yml       # db + redis + web + celery_worker + test
├── Dockerfile
├── requirements.txt         # 含 celery, redis, pytest, pytest-django, pytest-cov
├── design.md                # 原始设计文档
├── REFACTOR_MIGRATION_TABLE.md  # views 拆分迁移表
└── progress_summary.txt     # 本文件

五、design.md 中尚未实现的部分（后续可迭代）
--------------------------------------------------------------------------------
- 输入校验（MRN 6 位、NPI 10 位、ICD-10 等）— serializer 尚未强制格式
- Duplication detection（patient/order/provider）— 已实现
- Error vs Warning 行为区分 — 已实现（BlockError/WarningException）
- PDF 解析（Patient Records）
- duplication_warning 在报表中的实际逻辑

六、尚未实现的部分
--------------------------------------------------------------------------------
- WebSocket/SSE 推送完成状态（当前用 Polling）

七、今日问答与发现
--------------------------------------------------------------------------------
- 测试策略：本地开发用 USE_SQLITE_FOR_TESTS=1 跑 pytest，无需 PostgreSQL；Docker 跑测试用 PostgreSQL 与生产一致
- 不需要整页刷新也能看到新完成的 care plan：点「Search Care Plans」会发起新请求查 DB，即可看到结果
- 「不自动更新」的含义：页面上无轮询、无推送；任何触发新 HTTP 请求的操作都能拿到最新数据
- Polling 实现后：前端提交后每 3 秒轮询 status API，completed/failed 时自动停止并展示
- Mock LLM：USE_MOCK_LLM=1 开发，=0 生产；可跑通 Redis → Worker → DB 全流程而不消耗 API
- 拆分后验证：E2E 跑一遍主流程即可，不必逐个 router 单独测

================================================================================
